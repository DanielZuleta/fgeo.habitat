---
title: "Habitat-species associations"
subtitle: "Given a number of species and habitat types in a plot, is each species significantly aggregated within habitats?"
author: "Mauro Lepore"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Habitat-species associations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
```

This article shows how to determine habitat-species associations with the function [`tt_test_one()`](https://forestgeo.github.io/fgeo.habitat/reference/tt_test_one.html), developed by Sabrina Russo, Daniel Zuleta, Matteo Detto, and Kyle Harms. 

To suggest changes to the source code please file a pull request on the GitHub repository of the relevant package. You can search all functions and packages [here](https://forestgeo.github.io/fgeo/articles/fgeo.html#functions). Each function's help file links to its source code.

## Setup

```R
# install.packages("remotes")
remotes::install_github("forestgeo/fgeo.habitat")
```

For details on how to install packages from GitHub, see [this article](https://fgeo.netlify.com/2018/02/05/2018-02-05-installing-packages-from-github/).

```{r}
library(fgeo.habitat)
# For data wranging and visualization
library(tidyverse)
```

```{r}
# For reproducible results
set.seed(1014)
```

## Load census and habitat data

Here we'll use example datasets that come with __fgeo.habitat__.

```{r}
census <- luquillo_tree6_random

str(census)
```

```{r}
habitat <- luquillo_habitat

# Must have
names(habitat)

str(habitat)
```


To load your own data, you may run something like this:

```R
load("PATH/CENSUS_DATA.rdata")
census <- CENSUS_DATA

load("PATH/HABITAT-DATA.rdata")
habitat <- HABITAT-DATA
```

## Pick data

We'll pick alive trees, of 10 mm or more, and of sufficiently abundant species.

```{r}
pick <- filter(
  census,
  # Keep only alive
  status == "A", 
  # Keep dbh of 10 mm or more (drops missing dbh)
  dbh >= 10
)
# Count number of rows per species
pick <- add_count(pick, sp)
# Keep sufficiently abundant trees
pick <- filter(pick, n > 50)

# Summary
unique(select(pick, sp, n))
```

## Overview

Before testing, we can overview the relationship between species an habitats with a plot.

```{r}
# Tweaks
offset <- 20 / 2
habitat2 <- mutate(
  habitat, 
  # Center species and habitat data
  x = x + offset, 
  y = y + offset,
  # From continuous to categorical
  habitats = as.factor(habitats)
)
```

```{r, out.width="90%", fig.widh=(6 * 0.9 / 0.7)}
ggplot(pick, aes(x = gx, y = gy)) +
  geom_raster(data = habitat2, aes(x, y, fill = habitats)) + 
  geom_point() +
  coord_fixed() +
  facet_wrap(~sp) +
  labs(fill = "Habitat")
```

## Test

### With `tt_test()` and any number of species

```{r}
all_sp <- unique(pick$sp)
out <- tt_test(all_sp, census, habitat)
head(out)
```

You can conveniently view the output with `View(out)` or -- to compare species side by side -- you can spread the values across species with `spread()`. 

```{r}
spread(out, sp, value)
```

### With `tt_test_one()` and one species

Before we used `tt_test()`, which is a wrapper around `tt_test_one()` -- the original function developed by Sabrina Russo, Daniel Zuleta, Matteo Detto, and Kyle Harms. This section shows how you may use `tt_test_one()` directly to test a single species. The following section shows how to extend the test to any number of species.

See `?tt_test_one()`; you'll find out that this function needs the name of one species, a census, and habitat data. All of these we already have (above). But `tt_test_one()` also needs plot dimensions, grid size and the abundance (count) of each species per quadrat-index.

We should find and store the plot dimensions and gridsize because we'll need them in more than one function and they must be consistent. To understand which values to choose we may inspect the structure of the habitat ([plot details](https://forestgeo.si.edu/sites/north-america/luquillo)).

```{r}
lapply(habitat, range)
```

You functions may also help you.

```{r}
extract_plotdim(habitat)
extract_gridsize(habitat)
```

These are the values we need.

```{r}
# For reuse
plot_dimensions <- c(320, 500)
grid_size <- 20
```

To calculate abundance per quadrat-index you may use the function [`abundanceperquad()`](https://s.si.edu/2JtN94p) from the original CTFSRPackage, or a more conservative wrapper, `abund_index()` from __fgeo.habitat__.

```{r}
# For details see ?abund_index (e.g. defaults to keep trees of dbh > 10 mm)
abundance <- abund_index(pick, plot_dimensions, grid_size)

str(abundance, list.len = 5)
```

Now that we have all we need, we can run `tt_test_one()`.

```{r}
one_species <- unique(pick$sp)[[1]]
one_species

out_one <- tt_test_one(
  species = one_species,
  hab.index20 = habitat,
  allabund20 = abundance,
  plotdim = plot_dimensions,
  gridsize = grid_size
)

out_one
```

You may transform the output into a dataframe with `tt_df()`.

```{r}
tt_df(out_one)
```

### With `tt_test_one()` and any number of species

To iterate over multiple species you may write a for loop, or use a functional such as `lapply()`.

```{r}
all_species <- unique(pick$sp)

out_all <- lapply(
  all_species,
  tt_test_one,
  hab.index20 = habitat,
  allabund20 = abundance,
  plotdim = plot_dimensions,
  gridsize = grid_size
)

out_all
```

Here again you may use `tt_df()` in combination with `View()` and `spread()`.

```{r}
spread(tt_df(out_all), sp, value)
```

## Data science workflows

Above we used `tt_test()` or a combination of `tt_test_one()` and `tt_df()` to output a dataframe. Compared to a matrix, a dataframe fits better in common workflows for data manipulation and visualization. The dataframe is the most important data structure used in __dplyr__, __ggplot2__, and all other packages in the tidyverse. Here are some examples of what you can do with our dataframe output. We'll use the pipe operator (`%>%`) to avoid saving intermediary results and to make our code more expressive -- where each line is an imperative statement that communicates our intention (for details see http://style.tidyverse.org/pipes.html).

* Transforming data.

```{r}
out %>% 
  mutate_if(is.character, tolower) %>% 
  mutate_if(is.numeric, round, 2) %>% 
  mutate(metric = str_replace_all(metric, fixed("."), "_")) %>% 
  head()
```

* Filtering interesting rows and arranging them as required.

```{r}
out %>% 
  filter(sp  %in% c("SLOBER", "PREMON"), grepl("Gr", metric)) %>% 
  arrange(metric, desc(value))
```

* Producing analytic summaries.

```{r}
out %>% 
  group_by(metric) %>% 
  summarise(mean = mean(value), max = max(value), min = min(value))
```

* Producing visual summaries.

```{r, out.width="90%", fig.widh=(6 * 0.9 / 0.7)}
ggplot(out, aes(sp, value, color = sp)) +
  geom_point() +
  facet_wrap("metric", scales = "free_y") +
  theme(axis.text.x = element_blank())
```

