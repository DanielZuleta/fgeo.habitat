---
title: "Habitat-species associations"
author: "Mauro Lepore"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Habitat-species associations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  warning = FALSE
)
```

Given a number of species and habitat types in a plot, is each species significantly aggregated within habitats?

We'll answer this question with the function [`torusonesp.all()`](https://forestgeo.github.io/fgeo.habitat/reference/torusonesp.all.html), developed by Sabrina Russo, Daniel Zuleta, Matteo Detto, and Kyle Harms.

### Setup

```R
# install.packages("remotes")
remotes::install_github("forestgeo/fgeo.habitat")
```

For details on how to install packages from GitHub, see [this article](https://fgeo.netlify.com/2018/02/05/2018-02-05-installing-packages-from-github/).

```{r}
library(fgeo.habitat)
# Packages for data wranging and visualization
library(tidyverse)
```

### Load census and habitat data

This example uses a small dataset from Luquillo.

```{r}
census <- luquillo_top3_sp

str(census)
```

The habitat data is based on measurements of elevation every 20 meters. (You may create habitats data with `fgeo.tool::create_habitat()`).

```{r}
habitat_data <- luquillo_habitat

# Must have
names(habitat_data)

str(habitat_data)
```

To load your own data, you may run something like this:

```R
load("<PATH>/<CENSUS_DATA>.rdata")
census_data <- <CENSUS_DATA>

load("<PATH>/<HABITAT_DATA>.rdata")
habitat_data <- <HABITAT_DATA>
```

We can overview the relationship between species an habitats with a plot.

```{r map-one-sp, out.width = "100%"}
offset <- 20 / 2
habitat_centered <- mutate(
  habitat_data, 
  # Center species and habitat data
  x = x + offset, 
  y = y + offset,
  # From continuous to categorical
  habitats = as.factor(habitats)
)

ggplot(census, aes(x = gx, y = gy)) +
  geom_raster(data = habitat_centered, aes(x, y, fill = habitats)) + 
  geom_point() +
  coord_fixed() +
  facet_wrap(~sp) +
  labs(fill = "Habitat")
```

### Pick data

Let's pick alive trees, of 10 mm or more, and of sufficiently abundant species.

```{r}
# The pipe (`%>%`) helps to avoid saving temporary intermediary objects
pick <- census %>% 
  # Keep only alive
  filter(status == "A") %>% 
  # Keep dbh of 10 mm or more (drops missing dbh)
  filter(dbh >= 10) %>% 
  # Keep sufficiently abundant trees
  add_count(sp) %>% 
  filter(n > 50)

# View
unique(select(pick, sp, n))
```

The habitat data suggests the plot dimensions and grid size we should use ([details](https://forestgeo.si.edu/sites/north-america/luquillo)).

```{r}
lapply(habitat_data, range)

plot_dimensions <- c(320, 500)
grid_size <- 20
```

### Abundance per quadrat

`torusonesp.all()` requires abundance per quadrat in a particular format, as calculated with [`abundanceperquad()`](https://s.si.edu/2JtN94p) from the original CTFSRPackage.

```{r}
# WARNING: Default keeps only trees which dbh > 10 mm, which drops missing dbh.
# We did such selection explicitely above, but keep this in mind. For details
# see ?abundanceperquad. 
abundance_per_quadrat <- abundanceperquad(
  pick,
  plotdim = plot_dimensions,
  gridsize = grid_size,
)$abund

str(abundance_per_quadrat, list.len = 5)
```

Now we have all we need to run `torusonesp.all()` for one and multiple species.

```{r}
one_species <- unique(pick$sp)[[1]]

out_one <- torusonesp.all(
  species = one_species,
  hab.index20 = habitat_data,
  allabund20 = abundance_per_quadrat,
  plotdim = plot_dimensions,
  gridsize = grid_size
)

# Friendly view
t(out_one)
```

To iterate over multiple species you may write a for loop, or use a functional such as `lapply()`.

```{r}
all_species <- unique(pick$sp)

out_all <- lapply(
  all_species,
  torusonesp.all,
  hab.index20 = habitat_data,
  allabund20 = abundance_per_quadrat,
  plotdim = plot_dimensions,
  gridsize = grid_size
)

# Friendly view
t(Reduce(rbind, out_all))
```

### Wrapper

We can wrap the code to run the Torus Translation Test into a convenient function, `ttt()`, to abstract out the boilperate code and focus on what matters most.

```{r}
ttt <- function(sp, ...) {
  out <- lapply(sp, torusonesp.all, ...)
  t(Reduce(rbind, out))
}

two_species <- sample(unique(pick$sp), 2)
ttt(
  two_species,
  hab.index20 = habitat_data,
  allabund20 = abundance_per_quadrat,
  plotdim = plot_dimensions,
  gridsize = grid_size
)
```

### Scaling up

Our result doesn't scale up very well. As the number of species increases the resulting matrix becomes harder to interpret and handle.

```{r}
bigger_census <- luquillo_tree6_random %>% 
  filter(status == "A", dbh >= 10) %>% 
  add_count(sp) %>% 
  filter(n > 15)

abundance <- abundanceperquad(
  bigger_census, plotdim = plot_dimensions, gridsize = grid_size
)$abund

many_sp <- unique(bigger_census$sp)
bigger_result <- ttt(
  many_sp,
  hab.index20 = habitat_data,
  allabund20 = abundance,
  plotdim = plot_dimensions,
  gridsize = grid_size
)
bigger_result
```

A solution is to convert the resulting object to a friendly long-format dataframe. 

```{r}
long_result <- bigger_result %>% 
  as.data.frame() %>% 
  add_column(metric = rownames(bigger_result)) %>% 
  gather(key = "sp", value = "value", -metric)
head(long_result)
```

Once again, we could wrap the re-formatting code into a handy function.

```{r}
gather_ttt <- function(ttt) {
  ttt %>% 
    as.data.frame() %>% 
    add_column(metric = rownames(ttt)) %>% 
    gather(key = "sp", value = "value", -metric)
}

long_result <- gather_ttt(bigger_result)
```

With this format, the dataframe is easier to manipulate, summarize and visualize. For example:

* Filtering interesting species.

```{r}
top_sp <- bigger_census %>% 
  count(sp) %>% 
  top_n(5) %>% 
  pull(sp)
top_sp

result_top_sp <- filter(long_result, sp %in% top_sp)
# Friendly view
spread(result_top_sp, sp, value)
```

* Producing analytic summaries.

```{r}
result_top_sp %>% 
  group_by(metric) %>% 
  summarise(mean = mean(value), max = max(value), min = min(value))
```

* Producing visual summaries.

```{r, out.width = "100%"}
ggplot(result_top_sp, aes(sp, value, color = sp)) +
  geom_point() +
  facet_wrap("metric", scales = "free_y") +
  theme(axis.text.x = element_blank())
```

